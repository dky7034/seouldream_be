# Redis 및 캐싱 도입 검토 보고서

**작성일:** 2026년 1월 6일  
**상태:** 도입 보류 (Deferred)

---

## 1. 결론
현재 프로젝트 단계(초기 구축 및 단일 서버 운영)에서는 **Redis를 도입하지 않음**을 결정함.  
대신, **MySQL 인덱싱 최적화**를 우선적으로 수행하고, 향후 성능 이슈 발생 시 단계적으로 캐싱 전략을 확장한다.

---

## 2. 도입을 보류한 이유

### 2.1. 인프라 오버헤드 (Over-engineering)
- **현재 상황:** 예상 트래픽(교회 구성원 수천 명 규모)은 MySQL 단일 인스턴스로도 충분히 처리 가능함.
- **판단:** Redis 컨테이너를 추가하고 관리/운영하는 비용이, 이를 통해 얻는 성능 이점보다 큼. 배포 및 운영 복잡도를 낮추는 것이 현재는 더 중요함.

### 2.2. 인증 구조 (JWT)
- **현재 상황:** Stateless한 JWT(Access Token) 방식을 사용 중이며, Refresh Token은 RDB(MySQL)에 저장하여 관리 중.
- **판단:** 세션 기반 인증이 아니므로 세션 저장소로서의 Redis가 필수적이지 않음. Refresh Token 조회 부하는 현재 RDB로도 충분히 감당 가능함.

### 2.3. 데이터 정합성 문제 (Cache Invalidation)
- **핵심 이슈:** 캐싱 적용 시, 원본 데이터(DB)가 수정/삭제될 때 캐시 데이터도 즉시 갱신하거나 제거해야 함.
- **판단:** 대시보드나 통계 데이터의 경우, 잦은 수정이 발생할 수 있음(예: 리더의 출석 보고 수정). 이를 실시간으로 캐시와 동기화하는 로직(`Cache Eviction`)을 구현하는 것은 개발 복잡도를 크게 높이며, 버그 발생 위험이 큼. 현 시점에서는 실시간 정합성이 성능보다 중요함.

---

## 3. 대안 및 단계별 전략

### 3.1. 1단계: DB 튜닝 (현재 단계)
- 쿼리 최적화 및 적절한 인덱스(Index) 설정을 통해 조회 속도 확보.
- `Dashboard` 및 `Statistics` 관련 집계 쿼리 실행 계획 점검.

### 3.2. 2단계: 로컬 캐시 (Local Cache)
- **대상:** 성능 저하가 뚜렷한 통계/대시보드 API.
- **방법:** Spring Boot 내장 캐시(ConcurrentMapCache) 또는 **Caffeine Cache** 사용.
- **장점:** 별도 인프라(Redis) 설치 없이 메모리 I/O만으로 압도적인 성능 제공. 단일 서버 환경에서 Redis보다 빠름.

### 3.3. 3단계: Redis 도입 (미래)
다음 조건이 충족될 때 Redis 도입을 재검토함.
1.  **Scale-out:** 서버가 2대 이상으로 늘어나, 로컬 캐시 동기화가 불가능해질 때.
2.  **보안 강화:** JWT 강제 만료(Logout Blacklist) 기능이 필수적으로 요구될 때.
3.  **트래픽 폭증:** DB 커넥션 풀이 고갈될 정도로 읽기 트래픽이 폭주할 때.
